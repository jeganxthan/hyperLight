#!/usr/bin/env bash

# Keep normal user shell config behavior.
if [ -f "$HOME/.bashrc" ]; then
  # shellcheck disable=SC1090
  source "$HOME/.bashrc"
fi

# Only for interactive shells.
case "$-" in
  *i*) ;;
  *) return 0 2>/dev/null || exit 0 ;;
esac

__kn_min_seconds=5
__kn_last_hist="${HISTCMD:-0}"
__kn_last_prompt_seconds=$SECONDS

__kn_precmd() {
  local exit_code=$?
  local current_hist="${HISTCMD:-0}"
  local duration=$((SECONDS - __kn_last_prompt_seconds))
  __kn_last_prompt_seconds=$SECONDS

  # Only react when a new history entry was added (real typed command).
  [ "$current_hist" -gt "$__kn_last_hist" ] || return "$exit_code"

  local cmd
  cmd="$(history 1 | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]+//; s/[[:space:]]+$//')"
  __kn_last_hist="$current_hist"

  # Ignore interrupted commands and short commands.
  [ "$exit_code" -eq 130 ] && return "$exit_code"
  [ "$duration" -ge "$__kn_min_seconds" ] || return "$exit_code"

  # Ignore trivial commands and VS Code shell-integration internals.
  [[ -z "$cmd" ]] && return "$exit_code"
  [[ "$cmd" =~ ^(ls|cd|pwd|clear|history|fc|exit|true|false)([[:space:]].*)?$ ]] && return "$exit_code"
  [[ "$cmd" =~ __ksi_prompt_command ]] && return "$exit_code"
  [[ "$cmd" =~ ^(builtin[[:space:]]+)?declare[[:space:]]+-F ]] && return "$exit_code"

  local title="Command finished"
  local body
  if [ "$exit_code" -eq 0 ]; then
    body="OK (${duration}s): ${cmd}"
  else
    body="Failed (${duration}s, code ${exit_code}): ${cmd}"
  fi

  command -v notify-send >/dev/null 2>&1 && notify-send "$title" "$body"
  return "$exit_code"
}

PROMPT_COMMAND="__kn_precmd${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
